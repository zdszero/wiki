<!doctype html>
<html >
<head>
    
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <meta http-equiv="Content-Style-Type" content="text/css" />

    <link rel="stylesheet" type="text/css" href="../../css/template.css" />
    <link rel="stylesheet" type="text/css" href="../../css/elegant_bootstrap.css" />

    <!-- <script src="https://code.jquery.com/jquery-2.2.1.min.js"></script> -->
    <!-- <script src="jquery.sticky-kit.js "></script> -->
  
    <meta name="generator" content="pandoc" />
  <meta name="author" content="zdszero" />
  <meta name="date" content="2022-07-09" />
  <title>sstable</title>
  <style type="text/css">code{white-space: pre;}</style>
</head>
<body>

    
    <div class="navbar navbar-static-top">
    <div class="navbar-inner">
      <div class="container">
        <span class="doc-title">sstable</span>
        <ul class="nav pull-right doc-info">
                    <li><p class="navbar-text">zdszero</p></li>
                              <li><p class="navbar-text">2022-07-09</p></li>
                  </ul>
      </div>
    </div>
  </div>
    <div class="container">
    <div class="row">
            <div id="TOC" class="span3">
        <div class="well toc">

        <ul>
        <li><a href="#sstable" id="toc-sstable">sstable</a></li>
        <li><a href="#memory-model" id="toc-memory-model">memory
        model</a></li>
        </ul>

        </div>
      </div>
            <div class="span9">
            <h2 id="sstable">sstable</h2>
            <p>虽然在内存中，所有的数据都是按序排列的，但是当多个memetable数据持久化到磁盘后，对应的不同的sstable之间是存在交集的，在读操作时，需要对所有的sstable文件进行遍历，严重影响了读取效率。因此leveldb后台会“定期“整合这些sstable文件，该过程也称为compaction。随着compaction的进行，sstable文件在逻辑上被分成若干层，由内存数据直接dump出来的文件称为level
            0层文件，后期整合而成的文件为level i
            层文件，这也是leveldb这个名字的由来。</p>
            <h2 id="memory-model">memory model</h2>
            <p><strong>sstable</strong></p>
            <table style="width:100%;">
            <colgroup>
            <col style="width: 16%" />
            <col style="width: 16%" />
            <col style="width: 16%" />
            <col style="width: 16%" />
            <col style="width: 16%" />
            <col style="width: 16%" />
            </colgroup>
            <thead>
            <tr class="header">
            <th style="text-align: center;">entry0</th>
            <th style="text-align: center;">entry1</th>
            <th style="text-align: center;">……</th>
            <th style="text-align: center;">restarts</th>
            <th style="text-align: center;">num_of_restarts</th>
            <th style="text-align: center;">trailer</th>
            </tr>
            </thead>
            <tbody>
            <tr class="odd">
            <td style="text-align: center;">第一个K-V entry</td>
            <td style="text-align: center;">第二个</td>
            <td style="text-align: center;">……</td>
            <td style="text-align: center;">分区前缀的offset</td>
            <td style="text-align: center;">总共压缩的轮数</td>
            <td style="text-align: center;">尾部其他信息</td>
            </tr>
            </tbody>
            </table>
            <p>如果不分区，对每个key的查找，都要从block的头开始，所以进一步细化粒度，对前缀进行分段处理。若干个（Option::block_restart_interval）key做前缀压缩之后，就重新开始下一轮。每一轮前缀压缩的
            block offset 保存在 restarts 中，num_of_restarts
            记录着总共压缩的轮数（有多少个前缀分区）。</p>
            <p><strong>entry</strong></p>
            <p>一份key-value数据作为block中的一个entry。虑节约空间，leveldb
            对 key 的存储进行前缀压缩，每个 entry 中会记录 key 与前一个
            key
            前缀相同的字节（shared_bytes）以及自己独有的字节（unshared_bytes）。读取时，对
            block 进行遍历，每个 key 根据前一个 key 以及
            shared_bytes/unshared_bytes 可以构造出来。</p>
            <table>
            <colgroup>
            <col style="width: 20%" />
            <col style="width: 20%" />
            <col style="width: 20%" />
            <col style="width: 20%" />
            <col style="width: 20%" />
            </colgroup>
            <thead>
            <tr class="header">
            <th style="text-align: center;">shared_bytes</th>
            <th style="text-align: center;">unshared_bytes</th>
            <th style="text-align: center;">value_bytes</th>
            <th style="text-align: center;">unshared_key_data</th>
            <th style="text-align: center;">value_data</th>
            </tr>
            </thead>
            <tbody>
            <tr class="odd">
            <td
            style="text-align: center;">当前key与前一个key相同的字节前缀数量</td>
            <td style="text-align: center;">不同的字节数量</td>
            <td style="text-align: center;">值的字节数量</td>
            <td style="text-align: center;">unshared data存储位置</td>
            <td style="text-align: center;">value存储位置</td>
            </tr>
            </tbody>
            </table>
            <p><strong>trailer</strong></p>
            <table>
            <thead>
            <tr class="header">
            <th style="text-align: center;">type(char)</th>
            <th style="text-align: center;">crc(uint32)</th>
            </tr>
            </thead>
            <tbody>
            <tr class="odd">
            <td style="text-align: center;">数据是否进行了压缩</td>
            <td style="text-align: center;">block的校验码</td>
            </tr>
            </tbody>
            </table>
            </div>
    </div>
  </div>

  <!-- <script src="https://vjs.zencdn.net/5.4.4/video.js"></script> -->
</body>
</html>
