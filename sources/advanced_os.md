% advanced_os
% zdszero
% 2022-06-09

## ch1 序章

* **什么是分布式系统？**

一个分布式系统是多个独立计算机的集合，该系统在用户看来就象一台单个计算机一样。

* **分布式系统的三个特性**

模块性、并行性、自治性

* **分布式系统与计算机网络的区别**

都提供了一个面向报文的异构性通信环境，从低层硬件和通信软件来看，二者没有什么区别。

在全局管理、并行操作、自治控制等方面分布式系统有着更高的要求，其主要区别在于系统的高层软件（操作系统、语言、数据库、应用软件）上。

* **分布式系统硬件分类**

弗林分类法，采用基于 **指令流数目** 和 **数据流数目** 作为分类依据

1. SISD(single instruction single   data)
2. SIMD(single instruction multiple data)
3. MISD(multiple instruction single data)
4. MIMD(multiple instruction multiple data)


我们把所有MIMD分为两类：具有共享存储器的多处理器系统；没有共享存储器的多计算机系统。

根据互连网络结构的不同，以上两个分类还可进一步细分：总线型、开关型。

另一种分类：紧耦合、松散耦合

## ch2 同步

### 时钟同步

**逻辑时钟同步算法**

我们不关系绝对时间是否准备，只要所有的机器都认同一个逻辑时间就可以，这样就可以保持相对时间前后的关系。

* **Lamport算法**

关于时间先后的定义：

1. 在同一进程中，如果事件a在事件b之前发生，则$C(a) < C(b)$
2. 如果a和b分别是一个消息的发送和接收事件，则$C(a) < C(b)$
3. 对所有事件a和b，$C(a) \ne C(b)$

每一个消息都含有一个发送者时钟的发送时间，当消息到达时，接收者将自己时钟的接收时间与发送时间相比较。如果接收时间小于等于发送时间，则接收者的时钟被修改成发送时间加1。如果接收时间大于发送时间，则不改变接收者的时钟。

**物理时钟同步算法**

* **Cristian算法**

使用集中的时间服务器对所有的机器进行同步。

设$\rho$为最大漂移率，则若要保证两个时钟相差不超过$\delta$，则时钟必须每$\delta / 2\rho$秒就同步一次，每台机器周期性地向时间服务器请求当前的时间。

* **Berkeley算法**

时间服务器周期地轮询每一个机器当前的时间。收到所有机器当前时间后，计算其平均值。然后，将该平均值发送给每一个机器。每一个机器都将自己的时钟调到这个平均值。

* **非集中时钟同步**

每隔一段时间每个机器广播自己的当前时间，然后每个机器受到其他所有机器的当前时间后，计算平均值。

### 分布式互斥

* **集中式互斥算法**

选择一个进程作为协调器。

* **分布式互斥算法（Ricart和Agrawala算法）**

当一个进程要进入一个临界区时，它就建立一个消息。该消息格式为`<Critical Section Name, PID, TIME>`。然后，将该消息发送给所有其它进程。

回复包含如下情况：

1. 回复OK
    * 不准备进入临界区
    * 准备进入临界区，但自己的时间戳较大
    * 退出临界区
2. 将消息排队
    * 已经在临界区内
    * 准备进入临界区，但自己的时间戳较小

一个进程在发送完请求消息后就一直等待所有进程回送的OK消息。只要所有的OK消息都到达，则它就可以进入指定的临界区。

* **令牌环算法**

令牌沿着环传递，如果收到令牌的进程如果不要进入临界区，则传递令牌给下一个进程。如果要进入临界区，则进入临界区、使用临界区、离开临界区，离开临界区后将令牌传递给下一个邻居。

### 分布式选举

* **欺负（bully）算法**

某一个发现leader无相应的向其他所有序号比它大的机器发送ELECTION请求，返回OK说明有比它大的机器，当前机器放弃成为leader，然后这样迭代进行，直到选出一个leader，然后leader向其他所有机器发送COORDINATOR消息。

* **环算法**

选出进程号最大的。环拓扑，下一节点故障，就发往下下节点。每个节点（进程）经手选举msg时，加上自己的进程号。Msg绕一圈回到始发点，始发点选出其中进程号最大的作为leader，并在环上广播new leader的进程号。共n-1 + n-1 = 2n-2个msg。

### 原子事务

* **事务的特性**

1. A: 全做或全部做
2. C: 系统的不变量在事务执行过程保持不变
3. I: 并发执行的事务与某个串行调度相同
4. D: 事务提交后不会丢失

* **并发控制**

加锁，2PL locking

乐观并发控制

### 分布式系统死锁

* **分类**

通信死锁、资源死锁

* **死锁处理方案**

鸵鸟算法、检测、预防、避免

* **分布式死锁检测**

协调者：通过一个协调者保存系统中的所有资源信息，以及资源的持有情况。

假死锁：协调者将错误的得出死锁存在的结论，并中止某个进程。由于信息的延迟，使得分布式系统中的许多死锁算法产生了类似的假死锁问题。

Chandy-Misra-Haas算法：message = `<blocking pid， sender pid， receiver pid>`，通过DFS不断修改`sender pid`和`receiver pid`并且发送，若消息转了一圈又到发送者，则说明系统存在死锁。

* **分布式死锁预防**

基于timestamp的 *wait die* 和 *wound wait*

Similarity: The older transaction will "win" over the newer transaction

Difference: 

```
Wait-die:
    The newer transactions are killed when:
        It (= the newer transaction) makes a reqeust for a lock being held by an older transactions
Wound-wait:
    The newer transactions are killed when:
        An older transaction makes a request for a lock being held by the newer transactions
```

对于 *wait die*，在老事务释放资源之前，新事务可能会多次abort自己，*wound wait* 没有这么差的特性。

## ch3 路由算法

### 一般类型网络的最短路径路由算法

* **djkstra**

* **ford**

```
init: d = destination， set D(d) = 0， mark all other nodes as (.， ∞)

foreach v != d
    foreach adjacent node w of v
        D(v) := min{D(v)， D(w) + l(w， v)}
    endfor
endfor
repeat the above operations util no change is made
```

* **ARPAnet**

与Ford算法比较相似，不同点如下：

* 算法中的节点都维护一个一般化的路由表
    * 这个路由表包含从这个节点到所有其它节点的最优路径的延迟
* 每隔固定的时间间隔，路由表就被传送到它的所有邻接节点，直到最小延迟表在某一点达到稳定为止。

### 特殊类型网络的单播路由算法

* **双向环**

* **2维网格**

![(1) (2) (3)](../docs/images/image_2022-06-10-15-31-03.png)

![(4)](../docs/images/image_2022-06-10-15-32-02.png)

(1) XY路由
(2) 最短且完全适应路由
(3) 折线路由
(4) 最大最短路径路由

方案(1)(2)(3)适用于网格，方案(4)适用于圆环

* **超立方**

$Q_{0}$，是只有一个节点的退化图

$Q_{n} = K_{2} \times Q_{n-1}$，具有$2^n$个节点，其中每一个节点的地址可以表示为$u = u_{n}u_{n-1} \cdots u_{1}$

两个节点$\mu， \omega$的最短路径长度（海明距离）为$H(\mu， \omega) = \sum_{i=1}^{n} h(\mu_{i}， \omega_{i})$，其中$h(\mu_{i}， \omega_{i}) =
\begin{cases}
    1 \text{， if $u_{i} \ne \omega_{i}$}\\
    0 \text{， if $\mu_{i} = \omega_{i}$}
\end{cases}$

### 特殊类型网络的多播路由算法

* **基于路径的方法**

* **基于树的方法**

**Lan贪婪组播算法**

节点0010打算向{0000，0001，1001，1100，1110}中的每个节点发送消息

1. xor得到多播集合的相对地址{0010，0011，1011，1110，1100}
2. 每一列1的个数组成一个列向量(3,2,4,2)
3. 选择第2维方向的邻居0000

**U-网格算法**

字典序：$x_1 \ne x_2 ? x_1 < x_2 : y_1 < y_2$

* 假定源节点是(0， 0)
    * 按照字典顺序重新排列目标节点
    * 将列表分为两个相等的子列表，源节点将多播消息发往第二个子列表的第一个节点
    * 重复上述过程直到每个子列表只有一个节点
* 否则，可重新定义排列顺序以便源节点成为第一个节点

## ch4 分布式系统模型

### 系统模型

* **数学函数型**
* **有限状态自动机**
* **工作站模型**
* **处理器池模型**

$\mu$：处理器处理速率

$\lambda$：请求到达速率

$T = 1 / (\mu - \lambda)$：平均处理时间 

$T' = 1 / (n\mu - n\lambda) = 1/n \cdot T$：n个系统的平均处理时间 

### 处理器分配算法

* **优化方向**

处理器利用率、平均响应时间、响应率、负载均衡

响应率 = 响应时间 / 执行时间

* **基于任务相互关系图的任务调度**

根据优先图和就绪队列或lex

* **基于图论的确定性分配算法**

* **集中式分配算法 up-down**

1. 使用一个协调器来维护一张使用情况表。
2. 协调器根据使用情况表来分配处理机。

目的：让每个工作站公平地使用系统处理机的计算能力，而不是尽可能地提高处理机的利用率。

* **层次分配算法**

将所有处理机以一种与物理拓扑结构无关的方式组织成一个逻辑分层结构。

若一个作业产生S个进程，系统必须为它分配S个处理机。作业可以在层次树上的任何一层次上创建，如果当前层次节点不够，

* **超载者启动**

当一个进程启动时，若创建该进程的机器发现自己超载，则随机找到一台空闲的机器分配任务。

* **欠载者启动**

当一个进程结束时，系统就检查自己是否欠载。如果是，就尝试找到一台超载的机器分配任务。

### 进程调度

基于协同调度概念的算法，考虑了进程间的通信以此来保证同一组中的所有进程都在同一个时间片不同处理机上同时运行。

### 系统容错

* **错误种类**

部件错误、系统错误、同步与异步系统容错

* **采用冗余容错**

1. 信息冗余
2. 时间冗余
3. 物理冗余：主动复制、主备份

* **协作一致性**

两军问题

### 实时分布式系统

## ch5 分布式资源管理

集中资源管理会出现 **饿死现象**

### 资源搜索算法

* **投标算法**

1. 申请者广播招标消息。
2. 当一个资源管理者接到招标消息时，如果该结点上有所需资源，则根据一定的策略计算出“标数”，然后发一个投标消息给申请者，否则回一个拒绝消息。
3. 当申请者收到所有回答消息后，根据一定策略选出一个投标者，并向它发一个申请消息。
4. 接到申请消息后，将申请者的名字登记入册，并在可以分配资源时发消息通知申请者。
5. 当资源使用完毕后，向分配资源的资源管理者归还资源。

更好的鲁棒性？

若发申请后很久未获得资源，则向中标者发一询问信：“你还在吗？”。若中标者未失效就立即予以肯定答复。若发询问信后未见回答，则重新广播招标信件。

如果采用环形的结构，如何优化？

若信中已附有投标，则将本节点的投标和它比较，优选一个附在信中传向下一个邻点。收到自己的招标信后，向中标的资源管理者发一封申请信。

* **回声算法**

* **由近及远算法**

通过类似BFS的方式遍历树中的资源管理者。

* **里卡特算法**

* **令牌算法**

## ch6 分布式程序设计

一个分布式程序

1. 可使程序分为若⼲干个可独⽴执⾏的程序模块
2. 这些程序模块可以在程序开始执⾏行前就按要求分布于各台计算机上
3. 也可以在程序执⾏行过程中逐个产⽣生出来

* **分布式程序设计特点**

分布性、通信性、鲁棒性

## ch7 移动分布计算

### mobile agent

**特点**：分布并行性、分布并行性、异步性、资源优化

### 主动网络

**实现方法**：离散型实现方法、集成性实现方法
